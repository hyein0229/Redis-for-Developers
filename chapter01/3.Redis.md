# Redis 란?
Remote dictionary server 의 약자로 레디스는 **고성능 키-값 유형의 인메모리 NoSQL 데이터베이스**이며, 오픈소스 기반의 데이터 저장소다. 

## Redis 의 특징 
### 실시간 응답(빠른 성능)
- 기존 온디스크(disk-based) 형태의 데이터베이스의 특징
    - 온디스크 DB 에선 데이터가 영구적으로 디스크에 저장된다. (캐싱되는 데이터나 있으나, 없는 것은 직접 디스크에서 찾아야 함)
    - 일반적으로 저장된 데이터를 찾을 땐 디스크의 데이터를 페이지 단위로 메모리에 올리고 메모리에서 찾는다.
    - 만약, 메모리에 없는 경우 다른 페이지를 또 메모리에서 올리고 찾는 과정을 반복한다.
    - HDD/SSD 와 같은 디스크는 RAM 보다 접근 속도가 현저히 느리므로, 디스크 IO 빈도가 높으면 성능을 저하시킨다.
- 인메모리 DB 장점
    - 모든 데이터가 메모리에 저장된다.
    - 즉, 디스크에 접근하는 과정 자체가 없어 데이터의 처리 성능이 아주 빠르다.

___

### 단순성
- 레디스는 키-값 형태로 관리하는 NoSQL
- 키에 매핑되는 값은 String, hash, set 등 다양한 데이터 구조가 저장될 수 있다.
    - 프로그래밍의 기본 자료 구조와 같으므로 추가적인 데이터 가공 없이 애플리케이션에서 쉽게 사용 가능하다.
- 임피던스 불일치(impedance mismatches) 해소
    - 기존 관계형 데이터베이스의 테이블과 프로그래밍 언어 간 데이터 구조, 기능의 차이로 인해 발생하는 충돌을 의미한다.
    - 레디스는 내장된 다양한 자료 구조를 통해서 이러한 충돌을 해소하여 개발이 편리해진다.
- 개발자에겐 100개가 넘는 오픈소스 클라이언트가 존재하며, 다수의 프로그래밍 언어가 지원된다.

**레디스는 `싱글 스레드`로 동작한다.**
- 주의할 점은 레디스는 싱글 스레드로 동작한다는 점이다.
- 정확히는 메인 스레드 1개와 별도의 스레드(보조) 3개, 총 4개로 동작한다.
- 하지만, 클라이언트의 커맨드를 처리하는 부분은 이벤트 루프를 이용한 싱글 스레드로 동작한다.
- 장점
    - 최소 하나의 코어만 있어도 레디스 사용할 수 있어 배포가 쉽고, CPU 가 적은 서버도 좋은 성능을 낼 수 있다. 
    - 멀티스레드 애플리케이션에서 요구되는 동기화나 Lock 메커니즘 없이도 안정적이고 빠르게 사용자의 요청을 처리할 수 있다.
- 단점
    - 싱글 스레드이므로 한 클라이언트의 커맨드 처리가 오래걸리면, 다른 사용자는 완료될 때까지 대기해야 한다.
    - 이러한 특징으로 인해 인적 장애가 발생할 가능성이 매우 높다. 
    - 레디스는 인메모리이므로 대부분은 빠른 응답을 하지만 반환이 느린 특정 커맨드가 존재한다.
    - 따라서 이러한 커맨드만 주의해서 사용하면 장애 가능성을 줄일 수 있으므로 알아두는 것이 좋다. 

___

### 고가용성
- 레디스는 자체적으로 HA(High Availability) 기능을 제공한다.
- 복제를 통해 데이터를 여러 서버에 분산시킬 수 있고, 센티널(sentinel)은 장애 상황을 탐지해 자동으로 failover 시켜준다.
- 애플리케이션에서 센티널 구조에선 master 에 장애가 발생해도 레디스 엔드포인트 변경 없이 정상화된 master 를 사용할 수 있다.

___

### 확장성
- 레디스에서 클러스터 모드를 사용하면 손쉬운 수평적 확장이 가능하다.
- 데이터는 클러스터 내에서 자동으로 샤딩된 후 저장되며, 여러 개의 복제본이 생성될 수 있다.
    - 데이터의 분리는 데이터베이스 레이어에서 처리되므로 애플리케이션 레이어에선 대상 데이터가 어느 샤드에 있는지 몰라도 된다.
    - 따라서 단일 레디스를 사용할 때와 동일하게 데이터를 가져오고 저장할 수 있다.
- 클러스터 구조에서 모든 인스턴스는 클러스터 버스라는 프로토콜을 이용해 서로 감시하고 있다.
    - 따라서 master 노드에 문제가 발생하면 자동으로 failover 를 시켜 고가용성을 유지할 수 있다.

___

### 클라우드 네이티브 - 멀티 클라우드
- 클라우드 네이티브란? 
    - 클라우드 환경에 특화된 애플리케이션의 개발 및 운영 방식을 의미
    - MSA, 컨테이너, 오케스트레이션, devOps 와 같은 현대의 개발 및 운영 패러다임을 포용
    - 빠른 배포와 확장성, 높은 복원력을 중심으로 한 애플리케이션을 추구한다.
- 레디스는 클라우드 네이티브 환경에서 빠른 데이터 접근 및 처리를 지원하는 구조로 인해, MSA 와의 연계에서 큰 장점을 가진다.
- 멀티 클라우드란?
    - 여러 클라우드 제공업체의 서비스를 동시에 혹은 혼합해 활용하는 전략
    - 단일 클라우드 환경의 장애나 제한된 자원에 대한 의존성을 줄이며, 각 클라우드 제공자의 강점을 활용할 수 있다.
    - 또한, 데이터가 특정 지역이나 국가 내에 물리적으로 위치하도록 조절할 수 있다.
        - 이로 인해 더 가까운 저장소에 위치를 설정할 수 있고 대기 시간을 줄이고 장애에 대응할 수 있다.
- 레디스는 멀티 클라우드와 같이 여러 클라우드 환경에 걸쳐 일관된 성능과 기능을 제공하여 서비스의 연속성과 일관성을 보장한다.
- 주요 클라우드 벤더에선 레디스를 같이 상품화하여 서비스를 제공하고 있다.
    - AWS 의 ElastiCache For Redis
    - Google Cloud 의 Cloud Memory store for Redis
    - Microsoft Azure 의 Azure Cache for Redis
    - NHN Cloud 의 EazyCache
    - Naver Cloud 의 Cloud DB for Redis
- 클라우드 상품을 통해 서비스를 구축하면 높은 가용성, 확장성, 강력한 성능을 쉽게 달성할 수 있다.

## MSA 와 레디스
### 데이터 저장소로서의 레디스
- 레디스는 MSA 에서 각 서비스별 개별 저장소로 사용하기에 적합하다.
- 왜?
    - 설치가 간편하다.
    - 최소한의 리소스만을 들여 막대한 처리량을 낼 수 있다.
    - 다양한 자료 구조를 제공하여, 각 요구 사항에 맞게 사용이 가능하다.
    - 사용이 간단하다.
    - 고가용성을 위해 로드 밸런서나 프록시 등 추가적인 서비스 설치가 필요 없다.
- 데이터 영속성
    - 인메모리 DB 이므로 기본적으로 메모리에 있는 데이터가 영구 저장은 안된다.
    - 하지만, AOF(Append only file) 와 RDB(Redis DataBase) 형식으로 디스크에 주기적으로 저장할 수 있다.
- 레디스에 장애가 발생해 데이터가 유실되더라도 백업 파일을 이용하여 다시 복구할 수 있다.

### 메시지 브로커로서의 레디스
- MSA 에서 각 서비스는 완전히 분리되어 있는 구조이므로, 서비스 간의 지속적 통신이 필요하다.
- 이때 메시지 큐 혹은 stream 과 같은 메시지 브로커를 이용해 서비스 간에 비동기적으로 데이터를 전달할 수 있는 채널이 있어야 한다.
- 레디스의 pub/sub
    - 레디스는 데이터 저장 뿐 아니라 메시지 전달에 매우 유용하다.
    - pub/sub 기능은 가장 간단한 메시징 기능으로, 굉장히 빠르고 간단하게 사용할 수 있다.
    - 1개의 채널에 데이터를 던지면 이 채널의 subscriber 들은 데이터를 빠르게 가져갈 수 있다.
    - 하지만, pub/sub 의 모든 데이터는 전달된 뒤 삭제되는 일회성이다.
        - fire-and-forget 패턴이 필요한 간단한 알림 서비스에선 유용하다.
        - 메시지가 삭제되므로 보존되어야 하는 경우엔 적합하지 않겟죠
- 레디스의 list 자료 구조는 메시지 큐로 사용하기 적합하다.
    - list 에서 데이터는 빠르게 push/pop 할 수 있다.
    - 애플리케이션에선 list 에 데이터가 있는 지 확인 없이, 대기하다가 list 에 데이터가 들어오면 즉시 읽을 수 있다.
    - 즉, 블로킹 기능 사용이 가능하다.
- 레디스의 stream 자료 구조를 사용하면 완벽한 스트림 플랫폼으로 사용 가능하다.
    - stream 은 Apache Kafka 에서 영감을 받아 만들어진 자료 구조이다.
    - 데이터는 계속해서 추가되는 방식으로 저장된다. (append-only)
    - kafka 처럼 producer-consumer 방식으로 동작하며 데이터의 분산 처리도 가능하다.
    - 저장된 데이터를 시간대별로 검색하는 것도 가능하다.