# 레디스에서 키를 관리하는 법
## 키의 자동 생성과 삭제
stream, set, sorted set, hash 와 같이 하나의 키에 여러 아이템을 가지고 있는 구조에선 명시적으로 키를 생성하거나 삭제하지 않아도 키는 알아서 생성되고 삭제된다.<br>
키의 생성과 삭제는 세 가지 공통 규칙을 따른다.

**1. 키가 존재하지 않을 때 아이템을 넣으면 삽입 전에 빈 자료구조를 생성한다.**
```shell
127.0.0.1:6379> DEL mylist
(integer) 1

127.0.0.1:6379> LPUSH mylist 1 2 3
(integer) 3
```

저장하고자 하는 키에 다른 자료 구조가 이미 생성되어 있으면 아이템을 추가하는 작업에서 에러를 반환한다.
```shell
127.0.0.1:6379> SET hello world
OK

127.0.0.1:6379> LPUSH hello 1 2 3
(error) WRONGTYPE Operation against a key holding the wrong kind of value

127.0.0.1:6379> TYPE hello
string
```
<br>

**2. 모든 아이템을 삭제하면 키도 자동 삭제된다. (stream 은 예외)**
```shell
127.0.0.1:6379> EXISTS mylist
(integer) 1

127.0.0.1:6379> LPOP mylist
"3"

127.0.0.1:6379> LPOP mylist
"2"

127.0.0.1:6379> LPOP mylist
"1"

127.0.0.1:6379> LPOP mylist
(nil)

127.0.0.1:6379> EXISTS mylist # 아이템이 모두 삭제되면, 키 자체가 없어짐
(integer) 0
```
<br>

**3. 키가 없는 상태에서 키 삭제, 아이템 삭제, 자료 구조 크기 조회 같은 읽기 전용 커맨드를 수행하면 에러를 반환하는 대신 키가 있으나 아이템이 없는 것처럼 동작한다.**
```shell
127.0.0.1:6379> EXISTS mylist
(integer) 0

127.0.0.1:6379> DEL mylist
(integer) 0

127.0.0.1:6379> LLEN mylist # 에러를 반환하진 않으나, 아이템이 없는 것처럼 동작
(integer) 0

127.0.0.1:6379> LPOP mylist
(nil)
```

## 키 조회 커맨드 종류
### `EXISTS`
```shell
EXISTS key [key ...]
```
키가 존재하는지 확인하는 커맨드이다. 존재하면 1을, 존재하지 않으면 0을 반환한다.
```shell
127.0.0.1:6379> SET hello world
OK

127.0.0.1:6379> EXISTS hello
(integer) 1

127.0.0.1:6379> EXISTS hello2
(integer) 0
```

### `KEYS`
```shell
KEYS pattern
```
- 레디스에 저장된 모든 키를 조회하는 커맨드이다.
- 매칭되는 패턴에 해당하는 모든 키의 list 를 반환한다.
- 패턴은 글롭 패턴(Glob pattern) 스타일로 동작한다.
- 패턴
    - h?llo: hello, hallo 매칭 가능
    - h*llo: hllo, heeeello 매칭 가능
    - h[ae]llo: hello, hallo 매칭 가능하지만, hillo 는 매칭 불가
    - h[^e]llo: hallo, hbllo 매칭 가능하지만, hello 는 매칭 불가
    - h[a-b]llo: hallo, hbllo 만 매칭 가능
- **주의점**
    - **KEYS 는 위험한 커맨드이다.**
    - 앞서 레디스는 싱글 스레드로 오래 수행되는 커맨드 작업 동안 다른 클라이언트의 커맨드는 차단된다고 하였다.
    - 이때, 이 위험성이 있는 커맨드의 대표 예시가 KEYS 커맨드이다.
    - KEYS 를 수행하면 메모리에 저장된 모든 키를 읽어와 반환하는 데 이 작업이 얼마나 걸릴지 예상할 수 없다.
    - 수초 내로 완료된다고 해도, 그 동안 다른 클라이언트는 데이터를 저장할 수 없고 대기열이 늘어날 수 있다. 
    - 또한 모니터링 도구가 master 노드에 보내는 healh check 에 응답을 할 수 없어 의도치 않은 failover 가 일어날 가능성도 있다.

```shell
127.0.0.1:6379> KEYS * # 모든 키 출력 (위험!)
 1) "mybitmap"
 2) "myset"
 3) "set2"
 4) "score:2025"
 5) "members"
 6) "logdata"
 7) "counter"
 8) "Product:234"
 9) "places"
10) "b"
11) "Product:123"
12) "NX"
13) "koreanfood"
14) "hello"
15) "a"
16) "c"
17) "score:220817"
18) "set1"
```

### `SCAN`
```shell
SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]
```
- **KEYS 커맨드를 대체하여 키를 조회**할 때 사용할 수 있는 커맨드이다.
- KEYS 는 한 번에 모든 키를 반환하는 커맨드지만, SCAN 은 커서를 기반으로 특정 범위의 키만 조회할 수 있어 비교적 안전하다.
- 기본적으로 한 번에 반환되는 키 개수는 10개이다.
```shell
127.0.0.1:6379> SCAN 0
1) "14"
2)  1) "logdata"
    2) "counter"
    3) "Product:123"
    4) "NX"
    5) "koreanfood"
    6) "myset"
    7) "set2"
    8) "score:2025"
    9) "hello"
   10) "a"

127.0.0.1:6379> SCAN 14
1) "0"
2) 1) "b"
   2) "mybitmap"
   3) "Product:234"
   4) "c"
   5) "score:220817"
   6) "members"
   7) "places"
   8) "set1"
```
- SCAN 0 
    - 이때 첫 번째로 반환되는 값 "14" 는 다음 SCAN 수행 시 인수로 사용해야 할 커서 위치이다.
    - 다음으로 반환되는 데이터는 저장된 키 list 이다.
    - 다음 SCAN 14 에서 다음 범위의 키 list 를 조회할 수 있다.
- SCAN 14
    - 다음 커서 값이 0 이 반환되었다. 이는 더 이상 검색할 키 값이 없다는 것을 의미한다.
- 클라이언트는 반환되는 첫 번째 인자가 0이 될 때까지 SCAN 을 반복 사용하여 저장된 모든 키를 확인할 수 있다.

___

**1. COUNT 옵션**
- 기본은 10개 반환이지만 이 옵션을 사용하여 개수를 조정할 수 있다.
- 하지만, 데이터가 정확하게 지정한 개수만큼 출력되진 않는다.
- 레디스는 메모리를 스캔하며 데이터가 저장된 형상에 따라 몇 개의 키를 더 읽는 것이 효율적이라고 판단하면 1~2개를 더 읽기 때문이다.
```shell
127.0.0.1:6379> SCAN 0 COUNT 7 # 7개 반환하도록 했으나, 8개가 반환되었다.
1) "22"
2) 1) "logdata"
   2) "counter"
   3) "Product:123"
   4) "NX"
   5) "koreanfood"
   6) "myset"
   7) "set2"
   8) "score:2025"
```
- COUNT 주의점
    - KEYS 처럼 이 COUNT 수를 너무 크게 지정하여 오랜 시간이 걸린다면 똑같이 서비스에 영향을 줄 수 있다.

**2. MATCH 옵션**
- 입력한 패턴에 맞는 키 값을 조회할 수 있다.
- 이때 반환되는 값은 사용자가 의도한 것과는 약간 다를 수 있다. 
- 우선 데이터를 필터링 없이 스캔한 다음 데이터를 반환하기 직전에 필터링하는 방식으로 동작하기 때문이다.

만약, keys:0 부터 key:200 까지 키가 있을 때, 11 이 포함된 키를 조회하고 싶다면?
```shell
127.0.0.1:6379> SET keys:4 1
OK

127.0.0.1:6379> SET keys:14 1
OK

127.0.0.1:6379> KEYS *4* # KEYS 패턴 매칭으로 조회, 모두 조회됨
1) "keys:14"
2) "keys:4"
3) "Product:234"

127.0.0.1:6379> SCAN 0 MATCH *4* # SCAN MATCH 패턴 매칭 조회 결과
1) "22"
2) 1) "keys:14"

127.0.0.1:6379> SCAN 22 MATCH *4*
1) "23"
2) 1) "keys:4"
   2) "Product:234"

127.0.0.1:6379> SCAN 23 MATCH *4*
1) "0"
2) (empty array)

# 아래는 SCAN MATCH 패턴 매칭의 동작 방식을 보여준다.
127.0.0.1:6379> SCAN 0
1) "22"
2)  1) "keys:2"
    2) "keys:14" # 여기
    3) "logdata"
    4) "counter"
    5) "keys:0"
    6) "Product:123"
    7) "NX"
    8) "koreanfood"
    9) "myset"
   10) "set2"
   11) "score:2025"

127.0.0.1:6379> SCAN 0 MATCH *4* # SCAN 0 의 결과에서 필터링하여 반환
1) "22"
2) 1) "keys:14"
```

**3. TYPE 옵션**
- 지정한 타입의 키만 조회할 수 있다.
- MATCH 옵션처럼 사용자에게 반환되기 전에 필터링되는 방식이므로 오래 걸릴 수도 있다.
```shell
127.0.0.1:6379> SCAN 0 TYPE string
1) "22"
2) 1) "keys:2"
   2) "keys:14"
   3) "counter"
   4) "keys:0"

127.0.0.1:6379> SCAN 0 TYPE list
1) "22"
2) 1) "logdata"

127.0.0.1:6379> SCAN 22 TYPE zset
1) "23"
2) 1) "score:220817"
```

SCAN과 비슷한 커맨드로는 SSCAN, HSCAN, ZSCAN 이 있다. 각각 set, hash, sorted set 에서 아이템을 조회하기 위해 사용되는 SMEMBERS, HGETALL, ZRANGE WITHSCORES 를 대체해서 서버에 최대한 영향을 끼치지 않고 반복 호출해서 사용할 수 있도록 하는 커맨드이다.

### `SORT`
```shell
SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]
```
- list, set, sorted set 에서만 사용할 수 있는 커맨드로, 키 내부의 아이템을 정렬해 반환한다.
- LIMIT 옵션을 사용하면 일부 데이터만 조회할 수 있다.
- ASC/DESC 옵션은 정렬 순서를 변경한다.
- 정렬할 대상이 문자열인 경우엔 ALPHA 옵션을 사용하여 데이터를 사전 순으로 정렬해 조회할 수 있다.
- BY 와 GET 옵션을 사용하면 정렬한 결과를 이용해 다른 키에 접근해서 데이터를 조회할 수 있다.

```shell
# 문자열 정렬하기
127.0.0.1:6379> LPUSH mylist a
(integer) 1

127.0.0.1:6379> LPUSH mylist b
(integer) 2

127.0.0.1:6379> LPUSH mylist c
(integer) 3

127.0.0.1:6379> LPUSH mylist hello
(integer) 4

# 127.0.0.1:6379> SORT mylist
# (error) ERR One or more scores can't be converted into double

127.0.0.1:6379> SORT mylist ALPHA # 문자열 정렬은 ALPHA 옵션 사용
1) "a"
2) "b"
3) "c"
4) "hello"

# 숫자 정렬
127.0.0.1:6379> LPUSH numbers 1
(integer) 1

127.0.0.1:6379> LPUSH numbers 2
(integer) 2

127.0.0.1:6379> LPUSH numbers 3
(integer) 3

127.0.0.1:6379> SORT numbers
1) "1"
2) "2"
3) "3"

127.0.0.1:6379> SORT numbers DESC
1) "3"
2) "2"
3) "1"
```

BY 와 GET 을 같이 사용해보자

```shell
# list 정렬
127.0.0.1:6379> SORT numbers
1) "1"
2) "2"
3) "3"

# hash 필드-값 쌍 아이템 저장
127.0.0.1:6379> HMSET user:1 name "hyein" age 25
OK
127.0.0.1:6379> HMSET user:2 name "jinju" age 25
OK
127.0.0.1:6379> HMSET user:3 name "juhyun" age 28
OK

#  hash 에 저장된 유저의 나이를 기준으로 정렬된 결과 출력하기
127.0.0.1:6379> SORT numbers BY user:*->age
1) "1"
2) "2"
3) "3"

# 나이를 기준으로 정렬했을 때 유저의 이름만 출력하기
127.0.0.1:6379> SORT numbers BY user:*->age GET user:*->name
1) "hyein"
2) "jinju"
3) "juhyun"

# 결과를 다른 키에 저장하기
127.0.0.1:6379> SORT numbers BY user:*->age GET user:*->name STORE sorted_names DESC
(integer) 3

127.0.0.1:6379> LRANGE sorted_names 0 -1
1) "juhyun"
2) "jinju"
3) "hyein"
```

### `RENAME/RENAMENX`
```shell
RENAME key newkey
RENAMENX key newkey
```
- 키의 이름을 변경한다.
- RENAMENX 의 경우엔 오직 변경할 키가 존재하지 않을 때에만 동작한다.
    - 즉, RENAMENX source destination 에서 destination 키가 존재하지 않을 경우만 성공한다.
```shell
# RENAME 예시
127.0.0.1:6379> SET a 1
OK

127.0.0.1:6379> SET b 2
OK

127.0.0.1:6379> RENAME a b # a 키를 b 로 이름 변경 성공
OK

127.0.0.1:6379> GET b # 기존 b 의 값이 a 값으로 덮어 쓰여짐
"1"

# RENAMENX 예시
127.0.0.1:6379> SET a 1
OK

127.0.0.1:6379> SET b 2
OK

127.0.0.1:6379> RENAMENX a b # b 는 이미 존재하여 이름 변경 실패
(integer) 0

127.0.0.1:6379> GET a
"1"

127.0.0.1:6379> GET b
"2"
```

### `COPY`
```shell
COPY source destination [DB destination-db] [REPLACE]
```
- source 키를 destination 키에 복사한다.
- destination 키가 이미 존재한다면 에러가 반환되는데, REPLACE 옵션은 키를 삭제하고 값을 복사하도록 하여 에러가 발생하지 않는다.
```shell
127.0.0.1:6379> SET B 12
OK

127.0.0.1:6379> COPY B BB # 존재하지 않는 키면 복사 성공
(integer) 1

127.0.0.1:6379> GET BB
"12"

127.0.0.1:6379> COPY B hello # 이미 존재하는 경우면 복사 실패
(integer) 0

127.0.0.1:6379> GET hello
"world"

127.0.0.1:6379> COPY B hello REPLACE # REPLACE 옵션으로 삭제 후 복사 성공
(integer) 1

127.0.0.1:6379> GET hello
"12"
```

### `TYPE`
```shell
TYPE key
```
지정한 키의 자료 구조 타입을 반환한다.

### `OBJECT`
```shell
OBJECT <subcommand> [<arg> [value] [opt] ...]
```
- 키에 대한 상세 정보를 반환한다.
- 사용할 수 있는 subcommand 옵션으로는 ENCODING, IDLETIME 등이 있다.
    - REFCOUNT: 해당 키의 참조 수 반환
    - ENCODING: 해당 키가 내부적으로 어떻게 저장됐는지
    - IDLETIME: 키가 호출되지 않은 시간이 얼마나 됐는지 
    - FREQ: LFU eviction 설정 시, 해당 키의 접근 빈도 
    - 등등

## 키 삭제 커맨드 종류
### `FLUSHALL`
```shell
FLUSHALL [ASYNC | SYNC]
```
- 레디스에 저장된 모든 키를 삭제한다. 
- SYNC flush 방식
    - 기본으로 동작 방식으로 모든 데이터가 삭제된 경우에만 OK 를 반환한다
    - 커맨드가 실행되는 도중에는 다른 응답 처리가 불가하여 차단된다.
- ASYNC flush 방식
    - 백그라운드로 실행된다.
    - 커맨드가 수행됐을 때 존재했던 키만 삭제해서 flush 되는 도중 생거난 키는 삭제되지 않는다.
    - 대량 데이터를 삭제해야 한다면 이 방식이 안전
- lazyfree-lazy-user-flush 옵션
    - 이 설정이 yes 인 경우 ASYNC 옵션 없이 FLUSHALL 을 사용해도 백그라운드로 키 삭제 작업이 동작한다.
    - 버전 7 기준으로 해당 옵션의 기본값이 no 이다.

```shell
127.0.0.1:6379> FLUSHALL
OK

127.0.0.1:6379> keys *
(empty array)

127.0.0.1:6379> CONFIG GET lazyfree-lazy-user-flush # 옵션 확인
1) "lazyfree-lazy-user-flush"
2) "no"
```

### `DEL`
```shell
DEL key [key ...]
```
- 키와 키에 저장된 모든 아이템을 삭제하는 커맨드이다.
- 기본적으로 동기적으로 동작한다.

### `UNLINK`
```shell
UNLINK key [key ...]
```
- DEL 과 비슷하게 키와 데이터를 삭제하는 커맨드다.
- 차이는?
    - 이 커맨드는 백그라운드에서 다른 스레드에 의해 처리되며, 우선 키와 연결된 데이터의 연결을 끊는다.
    - set, sorted set 과 같이 하나의 키에 여러 아이템이 존재하는 자료 구조의 경우 DEL 커맨드는 서버에 영향이 있을 수 있다.
    - 만약, 100만 개 아이템이 저장된 sorted set 키를 DEL 로 삭제하면 100만 개를 동기적으로 삭제하여, 수행 동안 다른 클라이언트 요청 처리가 불가하다.
    - 키에 저장된 아이템이 많은 경우 UNLINK 를 사용해 데이터를 삭제하는 것이 좋다.
- lazyfree-lazy-user-del 옵션
    - yes 인 경우 모든 DEL 커맨드는 UNLINK 방식으로 동작하여 백그라운드에서 키를 삭제한다.
    - 버전 7 기준으로 기본값은 no 이다.
    
```shell
127.0.0.1:6379> EXISTS a
(integer) 1

127.0.0.1:6379> UNLINK a # 삭제
(integer) 1

127.0.0.1:6379> EXISTS a
(integer) 0

127.0.0.1:6379> keys *
1) "b"
```

## 키의 만료 시간 관련 커맨드 종류
### `EXPIRE`
```shell
EXPIRE key seconds [NX | XX | GT | LT]
```
- 키가 만료될 시간을 초 단위로 정의할 수 있다.
- 옵션
    - NX: 해당 키에 만료 시간이 정의되어 있지 않은 경우에만 커맨드 수행
    - XX: 해당 키에 만료 시간이 정의되어 있는 경우만 커맨드 수행
    - GT: 현재 키가 가지고 있는 만료 시간보다 입력값이 큰 경우에만 수행
    - LT: 현재 키가 가지고 있는 만료 시간보다 입력값이 작은 경우에만 수행
```shell
127.0.0.1:6379> EXPIRE b 5 # 만료 시간 설정
(integer) 1

127.0.0.1:6379> GET b
"1"

127.0.0.1:6379> GET b
"1"

127.0.0.1:6379> GET b # 5초 후 자동 삭제
(nil)
```

### `EXPIREAT`
```shell
EXPIREAT key unix-time-seconds [NX | XX | GT | LT]
``` 
- 키가 특정 유닉스 타임스팸프에 만료될 수 있도록 직접 지정할 수 있다.

### `EXPIRETIME` 
```shell
EXPIRETIME key
```
- 키가 삭제되는 유닉스 타임스탬프를 초 단위로 반환한다.
- 키가 존재하지만 만료 시간이 설정되어 있지 않다면 -1 을, 키가 없을 땐 -2 를 반환한다.
```shell
127.0.0.1:6379> EXPIRETIME b
(integer) -2

127.0.0.1:6379> SET b 1
OK

127.0.0.1:6379> EXPIRE b 5 # 만료 시간 5초 설정
(integer) 1

127.0.0.1:6379> EXPIRETIME b
(integer) 1754299194

127.0.0.1:6379> EXPIRETIME b 
(integer) -2
```

### `TTL`
```shell
TTL key
```
- 키가 몇 초 뒤에 만료되는지 반환한다.
- 키가 존재하지만 만료 시간이 설정되어 있지 않다면 -1, 키가 없는 경우엔 -2를 반환한다.
```shell
127.0.0.1:6379> EXPIRE b 5
(integer) 1

127.0.0.1:6379> TTL b # 3초 남음
(integer) 3

127.0.0.1:6379> TTL b # 1초 남음
(integer) 1

127.0.0.1:6379> TTL b # 키 삭제됨
(integer) -2
```

PEXPIRE, PEXPIREAT, PEXPIRETIME, PTTL 은 밀리초(ms) 단위로 계산된다는 점만 다르고 동일하게 동작한다.