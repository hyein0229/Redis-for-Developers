# String 
- String 은 레디스에서 데이터를 저장할 수 있는 가장 간단한 자료 구조이다.
- 최대 512MB 의 문자열을 저장할 수 있다.
- 이진 데이터를 포함하는 모든 종류의 문자열이 binary-safe 하게 처리되므로 JPEG 이미지와 같은 바이트 값, HTTP 응답 값 등의 다양한 데이터를 저장할 수 있다.
- String 은 키와 실제 저장되는 아이템이 일대일로 연결되는 유일한 자료 구조이다.
    - 다른 자료 구조는 하나의 키에 여러 개의 아이템이 저장된다.

## Command 종류
### `SET` 
```shell
❯ docker exec -it redis redis-cli
127.0.0.1:6379> SET hello world # 데이터 저장
OK

127.0.0.1:6379> GET hello # 키로 데이터 조회
"world"

127.0.0.1:6379> SET hello test # 값 덮어쓰기
OK

127.0.0.1:6379> GET hello
"test"
```
- 이때, 만약 hello 라는 키에 이미 다른 값이 연결되어 있다면?
    - 기존 값은 새로 입력되는 값으로 대체된다.
    - 저장되어 있던 값이 string 이든, 다른 형태의 자료 구조든 항상 동일하게 동작한다.

**NX 옵션**
```shell
127.0.0.1:6379> SET hello newval NX # NX 옵션을 사용하면 키가 없을 때만 새로운 키 저장
(nil)

127.0.0.1:6379> GET hello
"test"
```
NX 옵션을 주면 이미 hello 키에 저장된 값이 있는 경우엔 값을 저장할 수 없다. 

**XX 옵션**
```shell
127.0.0.1:6379> SET hello newval XX # 키가 있을 때만 새로운 값으로 덮어쓰기
OK

127.0.0.1:6379> GET hello
"newval"

127.0.0.1:6379> SET hello2 newval XX # 키가 존재하지 않으면 저장 불가
(nil)
```
이미 hello 라는 키가 존재하는 경우만 새로운 값을 저장할 수 있다.

### `INCR`, `INCRBY`
- 숫자 형태의 문자열도 저장 가능하며, 숫자를 **원자적으로** 조작도 가능하다. 
- **원자적이다?**
    - 즉, 데이터를 읽고, 증가시키고, 저장하는 일련의 과정이 모두 하나로 처리된다.
    - 위 과정을 수행할 땐 다른 클라이언트가 키에 접근할 수 없음이 보장된다.
    - 같은 키에 접근하는 여러 클라이언트가 경쟁 상태(race condition)을 발생시킬 일이 없다.
    - 따라서 커맨드를 수행한 타이밍, 순서에 따라 이미 실행한 커맨드가 무시되거나 중복 처리되어 수행 결과가 잘못 나올 일이 없다.
```shell
127.0.0.1:6379> SET counter 100
OK

127.0.0.1:6379> INCR counter # 증가
(integer) 101

127.0.0.1:6379> INCR counter
(integer) 102

127.0.0.1:6379> INCRBY counter 50
(integer) 152

127.0.0.1:6379> DECR counter # 감소
(integer) 151

127.0.0.1:6379> DECRBY counter 51
(integer) 100
```
- INCR: 1씩 증가
- INCRBY: 입력한 값만큼 데이터 증가
- DECR, DECRBY 커맨드는 위와 같은 방식으로 감소시키는 커맨드이다.

### `MSET`, `MGET`
한 번에 여러 키를 조작할 수 있다.
```shell
127.0.0.1:6379> MSET a 10 b 20 c 30
OK

127.0.0.1:6379> MGET a b c
1) "10"
2) "20"
3) "30"
```
- MSET: 여러 키-값을 한 번에 저장
- MGET: 여러 키의 값을 한 번에 조회
- **장점**
    - 성능이 중요한 대규모 시스템은 ms 단위의 속도 향상도 서비스 전체의 속도 향상으로 이어질 수 있다. 
    - 따라서 MGET, MSET 커맨드를 활용하여 네트워크 통신 시간을 줄이면 서비스의 응답 속도를 향상시킬 수 있다.


