# list
- 리스트는 순서를 가지는 문자열의 목록이다.
- 하나의 list 는 최대 42억여 개의 아이템을 저장할 수 있다.
- 인덱스를 이용해 데이터에 직접 접근도 가능하며, 일반적으로 list 는 서비스에서 스택과 큐로서 사용된다.

## Command 종류
### `LPUSH`, `RPUSH`, `LRANGE`
```shell
127.0.0.1:6379> LPUSH mylist E # E
(integer) 1

127.0.0.1:6379> RPUSH mylist B # E B
(integer) 2

127.0.0.1:6379> LPUSH mylist D A C B A # A B C A D E B
(integer) 7

127.0.0.1:6379> LRANGE mylist 0 -1
1) "A"
2) "B"
3) "C"
4) "A"
5) "D"
6) "E"
7) "B"

127.0.0.1:6379> LRANGE mylist 0 3
1) "A"
2) "B"
3) "C"
4) "A"
```
- LPUSH: 왼쪽에(head)에 데이터를 추가 
- RPUSH: 오른쪽(tail)에 데이터를 추가 
    - 만약 여러 아이템을 한 번에 넣으면 나열된 순서대로 먼저 들어간다.
- LRANGE: 리스트에 들어있는 데이터를 조회
    - 시작과 끝 아이템의 인덱스를 각각 인수로 받아서 출력
    - 인덱스는 음수가 될 수 있으며 가장 오른쪽에 있는 아이템 인덱스는 -1, 그 앞은 -2가 된다.
    - 범위 0, -1 은 전체 데이터를 출력하라는 것과 같다.

### `LPOP`, `RPOP`
```shell
127.0.0.1:6379> LPOP mylist
"A"

127.0.0.1:6379> LPOP mylist 2
1) "B"
2) "C"

127.0.0.1:6379> LRANGE mylist 0 -1
1) "A"
2) "D"
3) "E"
4) "B"

127.0.0.1:6379> LRANGE mylist2 0 -1 # 없는 키일 땐 empty
(empty array)
```
- LPOP: 리스트에 저장된 첫 번째 아이템을 반환하는 동시에 삭제한다.
    - 숫자와 함께 사용하면 지정한 숫자만큼의 아이템을 반복 반환한다.
- RPOP: 리스트 끝에 저장된 아이템 대상

### `LTRIM`
```shell
127.0.0.1:6379> LTRIM mylist 0 1 # 범위가 아닌 아이템은 삭제
OK

127.0.0.1:6379> LRANGE mylist 0 -1
1) "A"
2) "D"
```
시작과 끝 아이템의 인덱스를 인자로 받아서 지정한 범위에 속하지 않는 아이템은 모두 삭제한다. (하지만, 반환하진 않는다.)

___

### LPUSH 와 LTRIM 같이 사용
- 두 커맨드를 같이 사용하면 고정된 길이의 큐를 쉽게 유지할 수 있다.
- ex. 리스트에 로그를 저장하는 상황인 경우, 로그는 계속 쌓이므로 주기적 삭제하여 공간을 확보하는 것이 필요하다.
- 만약, 1000개의 로그만 보관하고 싶다면?
```shell
127.0.0.1:6379> LPUSH logdata <data>
(integer) 1

127.0.0.1:6379> LRANGE logdata 0 -1
1) "<data>"

127.0.0.1:6379> LTRIM logdata 0 999 # 첫 1000개만 유지
OK
```
- 여기서 함께 사용한다는게? 트랜잭션 처리로 하거나 원자적으로 수행한다는 말인가?
- 로그 데이터를 계속 쌓으면서 주기적 배치 처리로 삭제하는 것보다 위 방식이 효율적이다.
    - 위처럼 같이 수행하면 무조건 1001번째가 되는 마지막 아이템 하나만 삭제되기 때문이다.
    - 리스트에서 tail 에 있는 아이템 삭제는 O(1) 로 동작하여 매우 빨라, 배치 처리 시마다 삭제할 아이템을 검색하는 과정보다 효율적이다.
- **list 시간 복잡도**
    - 양 끝에 데이터를 넣고 빼는 LPUSH, RPUSH, LPOP, RPOP 커맨드는 O(1) 로 매우 빠르다.
    - 하지만 인덱스나 데이터를 이용해 중간 데이터에 접근할 땐 O(n) 이며 저장된 데이터가 많을 수록 성능 저하가 일어난다.

### `LINSERT`
- 원하는 데이터의 앞이나 뒤에 데이터 추가를 할 수 있다. 
- 데이터의 앞에 추가하려면 BEFORE 옵션을, 뒤에 추가하려면 AFTER 옵션을 추가하면 된다.
    - 만약에 지정한 데이터가 없다면 오류를 반환한다.
```shell
127.0.0.1:6379> LRANGE mylist 0 -1
1) "A"
2) "D"
3) "C"
4) "D"

127.0.0.1:6379> LINSERT mylist BEFORE D E # D 앞에 E 추가
(integer) 5

127.0.0.1:6379> LRANGE mylist 0 -1 # 가장 처음 만난 D 앞에 추가됨
1) "A"
2) "E"
3) "D"
4) "C"
5) "D"

127.0.0.1:6379> LINSERT mylist BEFORE F E # 지정한 데이터가 없는 경우
(integer) -1
```

### `LSET`
- 지정한 인덱스의 데이터를 신규 입력하는 데이터로 덮어 쓴다.
    - 인덱스는 0부터 시작
- 만약 리스트의 범위를 벗어난 인덱스라면 에러를 반환한다.
```shell
127.0.0.1:6379> LRANGE mylist 0 -1
1) "a"
2) "E"
3) "D"

127.0.0.1:6379> LSET mylist 2 F # 인덱스 2의 값을 F로 바꿈
OK

127.0.0.1:6379> LRANGE mylist 0 -1
1) "a"
2) "E"
3) "F"

127.0.0.1:6379> LSET mylist 100 F # 인덱스 범위를 벗어났을 때
(error) ERR index out of range
```

### `LINDEX`
지정한 인덱스의 데이터를 확인할 수 있다.
```shell
127.0.0.1:6379> LRANGE mylist 0 -1
1) "a"
2) "E"
3) "F"

127.0.0.1:6379> LINDEX mylist 1 # 1번 인덱스 값 조회
"E"
```